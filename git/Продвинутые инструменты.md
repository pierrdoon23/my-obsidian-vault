
### **1. Интерактивный ребейз (`git rebase -i`)**
Позволяет переписывать историю коммитов: объединять, удалять, редактировать или менять порядок коммитов.  
**Пример:**
```bash
git rebase -i HEAD~5  # Редактировать последние 5 коммитов
```
- **Команды в редакторе:** `squash` (объединить), `edit` (изменить), `drop` (удалить), `reword` (переименовать сообщение).

---

### **2. Cherry-pick (`git cherry-pick`)**
Переносит отдельные коммиты из одной ветки в другую.  
**Пример:**
```bash
git cherry-pick a1b2c3d  # Применить коммит с хешем a1b2c3d к текущей ветке
```

---

### **3. Поиск ошибок через `git bisect`**
Автоматизирует поиск коммита, который внес баг, используя бинарный поиск.  
**Пример:**
```bash
git bisect start
git bisect bad        # Текущий коммит содержит ошибку
git bisect good v1.0  # Указать коммит, где ошибки не было
# Git будет перемещаться между коммитами, пока не найдет проблемный
git bisect reset      # Выйти из режима поиска
```

---

### **4. Reflog (`git reflog`)**
Спасает потерянные коммиты, показывает историю всех действий (переключения веток, сбросы и т.д.).  
**Пример:**
```bash
git reflog  # Показать журнал изменений указателей (HEAD, веток)
git checkout HEAD@{2}  # Перейти к состоянию из записи reflog
```

---

### **5. Временное сохранение изменений (`git stash`)**
Позволяет спрятать незакоммиченные изменения и восстановить их позже.  
**Пример:**
```bash
git stash              # Спрятать изменения
git stash pop          # Вернуть последние спрятанные изменения и удалить их из stash
git stash list         # Показать список сохраненных stash
git stash apply stash@{1}  # Применить конкретный stash
```

---

### **6. Submodules (`git submodule`)**
Встраивает другие репозитории как подпроекты.  
**Пример:**
```bash
git submodule add https://github.com/user/repo.git  # Добавить подмодуль
git submodule update --init --recursive  # Инициализировать и обновить подмодули
```

---

### **7. Фильтрация истории (`git filter-repo`)**
Переписывает историю, чтобы удалить конфиденциальные данные или большие файлы.  
**Пример (требуется установка `git-filter-repo`):**
```bash
git filter-repo --path-separator / --path "passwords.txt" --invert-paths  # Удалить файл из истории
```

---

### **8. Хуки (Git Hooks)**
Скрипты, которые запускаются автоматически при определенных событиях (например, перед коммитом).  
**Пример:**  
- Файл `.git/hooks/pre-commit` для проверки стиля кода.
- Используйте инструменты вроде **Husky** для удобного управления хуками.

---

### **9. Работа с патчами (`git format-patch`, `git am`)**
Создает и применяет патчи (изменения) в виде текстовых файлов.  
**Пример:**
```bash
git format-patch HEAD~2  # Создать патчи для последних 2 коммитов
git am *.patch           # Применить патчи к текущей ветке
```

---

### **10. Просмотр изменений в файлах (`git blame`)**
Показывает, кто и когда вносил изменения в конкретные строки файла.  
**Пример:**
```bash
git blame file.txt  # Увидеть авторов каждой строки
```

---

### **11. Интеграция с внешними инструментами (`git difftool`, `git mergetool`)**
Используйте сторонние программы (например, **Beyond Compare**, **Meld**) для сравнения и слияния файлов.  
**Пример:**
```bash
git difftool HEAD~1  # Сравнить изменения с помощью внешней утилиты
```

---

### **12. Автоисправление опечаток (`git help -a`, `git config help.autoCorrect`)**
Git может автоматически исправлять опечатки в командах.  
**Пример:**
```bash
git config --global help.autoCorrect 10  # Исправлять опечатки после 0.1 секунды
```

---

### **13. Подпись коммитов (GPG)**
Подписывайте коммиты криптографически для подтверждения авторства.  
**Пример:**
```bash
git commit -S -m "Signed commit"  # Создать подписанный коммит
```

---

### **Советы по безопасности:**
- **Не перезаписывайте историю** в общих ветках (используйте `git revert` вместо `git reset`).
- Перед операциями с историей сделайте бэкап (`git clone --mirror`).
- Используйте `git push --force-with-lease` вместо `git push --force` (он безопаснее).

---

Эти инструменты требуют практики, но они значительно упрощают работу с Git в сложных сценариях. Для углубленного изучения смотрите документацию или книги вроде *"Pro Git"*.