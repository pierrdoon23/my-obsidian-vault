
### Паттерн Middleware в Node.js

Middleware (промежуточное ПО) — это функции, которые обрабатывают HTTP-запросы и ответы в Node.js-приложениях, особенно в фреймворках типа Express.js. Они позволяют разделить логику обработки запросов на отдельные этапы, что делает код модульным, гибким и легко поддерживаемым.

---

#### **Как работает Middleware?**
1. **Последовательность выполнения**  
   Middleware выполняются в порядке их объявления. Каждая функция получает:
   - `req` (объект запроса),
   - `res` (объект ответа),
   - `next` (функция для передачи управления следующему middleware).

2. **Типы Middleware**:
   - **Глобальные**: Обрабатывают все запросы (например, логирование).
   - **Локальные**: Применяются к конкретным маршрутам (например, аутентификация).

---

#### **Примеры Middleware**

**1. Базовый пример (логирование запросов)**  
```javascript
const express = require('express');
const app = express();

// Middleware для логирования времени запроса
app.use((req, res, next) => {
  console.log(`Время запроса: ${new Date().toISOString()}`);
  next(); // Передаем управление следующему middleware
});

app.get('/', (req, res) => {
  res.send('Главная страница');
});

app.listen(3000);
```

**2. Middleware для аутентификации**  
```javascript
// Проверка авторизации
const authMiddleware = (req, res, next) => {
  const token = req.headers.authorization;
  if (token === 'secret') {
    next(); // Пользователь авторизован
  } else {
    res.status(401).send('Доступ запрещен');
  }
};

// Применяем только к защищенному маршруту
app.get('/admin', authMiddleware, (req, res) => {
  res.send('Админ-панель');
});
```

**3. Встроенные Middleware в Express**  
```javascript
app.use(express.json()); // Парсинг JSON-тела запроса
app.use(express.static('public')); // Раздача статических файлов
```

---

#### **Особенности Middleware**
1. **Порядок имеет значение**  
   Middleware выполняются в порядке их объявления. Например, если CORS-настройки добавлены после маршрутов, они не будут применены.

2. **Обработка ошибок**  
   Middleware для ошибок принимает 4 аргумента: `(err, req, res, next)`.  
   Пример:
   ```javascript
   app.use((err, req, res, next) => {
     console.error(err.stack);
     res.status(500).send('Что-то сломалось!');
   });
   ```

3. **Прерывание цепочки**  
   Если middleware не вызывает `next()`, обработка запроса останавливается:
   ```javascript
   app.use((req, res, next) => {
     if (req.ip === '127.0.0.1') {
       res.status(403).send('Доступ с localhost запрещен');
     } else {
       next();
     }
   });
   ```

---

#### **Практическое применение**
- **Логирование**: Замер времени выполнения, сбор метрик.
- **Аутентификация/Авторизация**: Проверка токенов, ролей пользователей.
- **Валидация данных**: Проверка входных параметров (например, с помощью Joi).
- **Сжатие ответов**: Использование `compression` для оптимизации трафика.
- **Кеширование**: Сохранение часто запрашиваемых данных.

---

#### **Типичные ошибки**
- **Забытый `next()`**: Запрос «зависает», если middleware не передает управление дальше.
- **Неправильный порядок**: Например, middleware для парсинга тела запроса должна быть объявлена до маршрутов, которые его используют.
- **Глобальные middleware для специфичных задач**: Не стоит добавлять тяжелую логику (например, парсинг PDF) в глобальные middleware — это замедлит все запросы.

---

#### **Итог**
Паттерн middleware — это основа архитектуры многих Node.js-приложений. Он позволяет:
- Декомпозировать код на независимые компоненты.
- Управлять потоком обработки запросов.
- Легко добавлять новую функциональность (например, проверку прав доступа).